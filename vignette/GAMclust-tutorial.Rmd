---
title: '[GAM-clustering](http://artyomovlab.wustl.edu/immgen-met/) Tutorial Notebook'
date: 2023/04/28
output:
  html_document:
    df_print: paged
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include=FALSE}
knitr::opts_chunk$set(
  comment = "#", 
  echo = TRUE,
  warning = FALSE,
  message = TRUE
)
```

Required packages to be installed:

```{r, eval=FALSE}
devtools::install_github("ctlab/fgsea")
devtools::install_github("ctlab/gatom")
devtools::install_github("ctlab/mwcsr")

library(fgsea)
library(gatom)
library(data.table)
# library(GAMclust)
devtools::load_all(getwd())

options(bitmapType='cairo')
set.seed(42)
```

### Preparing working environment

First, please load and initialize all objects required for GAM-clustering analysis:

(1) load one of the provided metabolic networks (we recommend to start with KEGG): `network.kegg.rds` is built based on the [KEGG database](https://www.genome.jp/kegg/), `network.rhea.rds` is built based on the [RHEA database](https://www.rhea-db.org/);

(2) load metabolites annotation: `met.kegg.db.rds` for KEGG network and `met.rhea.db.rds` is for RHEA network;

```{r, eval=FALSE}
# KEGG:

network <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/network.kegg.rds"))

metabolites.annotation <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/met.kegg.db.rds"))

# Rhea:

# network <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/network.rhea.rds"))

# metabolites.annotation <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/met.rhea.db.rds"))
```

(3) load species-specific network annotation: `org.Hs.eg.gatom.anno` for human data or `org.Mm.eg.gatom.anno` for mouse data;

```{r, eval=FALSE}
# human:

network.annotation <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/org.Hs.eg.gatom.anno.rds"))

# mouse:

network.annotation <- readRDS(url("http://artyomovlab.wustl.edu/publications/supp_materials/GATOM/org.Mm.eg.gatom.anno.rds"))

# rat:

# network.annotation <- readRDS("org.Rn.eg.gatom.anno.rds")
```

(4) load provided list of metabolites that should not be considered during the analysis as connections between reactions (e.g., CO2, HCO3-, etc);

```{r, eval=FALSE}
met.to.filter <- data.table::fread(system.file("mets2mask.lst", package="GAMclust"))$ID
```

(5) initialize SMGWCS solver: we recommend to use here either heuristic relax-and-cut solver `rnc_solver` from `mwcsr` package or to install proprietary [CPLEX solver](https://www.ibm.com/products/ilog-cplex-optimization-studio) (free for academy) on your computer (find more info in `mwcsr`'s [official documentation](https://github.com/ctlab/mwcsr) regarding both approaches);

```{r, eval=FALSE}
# relax-and-cut solver:

# solver <- mwcsr::rnc_solver()

# CPLEX SOLVER:

# cplex.dir <- "/nfs/home/againullina/lib/sgmwcs/private-libraries/CPLEX_Studio1271"
cplex.dir <- "/opt/ibm/ILOG/CPLEX_Studio1271"
solver <- mwcsr::virgo_solver(cplex_dir = cplex.dir)
```

(6) set working directory where the results will be saved to.

```{r, eval=FALSE}
# work.dir <- "/mnt/tank/scratch/againullina/testdata/tms_delCor2_10-5_0.5-0.05"
work.dir <- "~/Documents/4projects/nets/GAM-clustering/runs/test"
dir.create(work.dir, showWarnings = F, recursive = T)
```

(7) TEMPORARY: collecting logs while developing the tool.

```{r, eval=FALSE}
stats.dir <- paste0(work.dir, "/stats")
dir.create(stats.dir, showWarnings = F, recursive = T)

log_file <- file(paste0(stats.dir, "/log.txt"), open = "wt")
sink(log_file, type = "output", append = TRUE)
sink(log_file, type = "message", append = TRUE)
```

### Preparing objects for the analysis

#### Preparing data

GAMclust works with bulk, single cell and spatial RNA-seq data.

If single cell and spatial RNA-seq data were processed by
[Seurat](https://satijalab.org/seurat/articles/essential_commands.html)
pipeline, we recommend to use `assay="SCT"` and `slot="scale.data"` for the
further analysis. In this case during data preprocessing please force either `residual.features` parameter of `SCTransform()` (in case of one-sample data) or `nfeatures` parameter of `SelectIntegrationFeatures()` (in case of multi-sample data) to keep 10,000 genes in `scale.data` slot. Example for spatial data is shown below.

##### Example of bulk RNA-seq data

```{r, eval=FALSE}
load("/home/octopus/Documents/4projects/immGen/final_objects/243_es.top12k.Rda")
E <- Biobase::exprs(es.top12k)
E[1:3, 1:3]
```

##### Example of single cell RNA-seq data

```{r, eval=FALSE}
seurat_object <- readRDS("/home/octopus/Documents/4projects/idb/1_aggression/subset_PE/per.rds")

seurat_object <- readRDS("/mnt/tank/scratch/againullina/testdata/tms12k.rds")

E <- as.matrix(Seurat::GetAssayData(object = seurat_object,
                                    assay = "SCT",
                                    slot = "scale.data"))

nrow(E) # ! make sure this value is equal to 10000

E[1:3, 1:3]
```

##### Example of spatial RNA-seq data

```{r, eval=FALSE}
seurat_object <- readRDS("/mnt/tank/scratch/againullina/testdata/275_T_seurat.rds")

genes.avrg <- Matrix::rowMeans(seurat_object@assays$Spatial@data)
genes.top10k <- names(head(sort(genes.avrg, decreasing = TRUE), 10000))
seurat_object <- Seurat::SCTransform(seurat_object, 
                                     assay = "Spatial", 
                                     residual.features = genes.top10k, 
                                     verbose = TRUE)

E <- as.matrix(Seurat::GetAssayData(object = seurat_object,
                                    assay = "SCT",
                                    slot = "scale.data"))

nrow(E) # ! make sure this value is equal to 10000

E[1:3, 1:3]
```

Genes in your dataset may be named as Symbol, Entrez, Ensembl or RefSeq IDs. One of these names should be specified as value of `gene.id.type` parameter in `prepareData()`. 

If you analyse singe cell or spatial RNA-seq data, please set `use.PCA=TRUE` in `prepareData()`.

```{r, eval=FALSE}
E.prep <- prepareData(E = E,
                      gene.id.type = "Symbol",
                      use.PCA = TRUE,
                      use.PCA.n = 50,
                      network.annotation = network.annotation)

E.prep[1:3, 1:3]
```

#### Preparing network

The `prepareNetwork()` function defines the structure of the final metabolic modules. 

```{r, eval=FALSE}
network.prep <- prepareNetwork(E = E.prep,
                               network = network,
                               met.to.filter = met.to.filter,
                               network.annotation = network.annotation)
```

#### Preclustering

The `preClustering()` function defines initial patterns using k-medoids clustering on gene expression matrix. It is strongly recommended to do initial clustering with no less than 32 clusters.

You can visualize the initial heatmap as shown below.

```{r, eval=FALSE, fig.width=20, fig.height=7}
cur.centers <- preClustering(E.prep = E.prep,
                             network.prep = network.prep,
                             initial.number.of.clusters = 32,
                             network.annotation = network.annotation)

cur.centers[1:3, 1:3]

pheatmap::pheatmap(
      normalize.rows(cur.centers),
      cluster_rows=F, cluster_cols=F,
      show_rownames=F, show_colnames=T)
```

### GAM-clustering analysis

Now you have everything prepared for the GAM-clustering analysis.

Initial patterns will be now refined in an iterative process. The output of `gamClustering()` function presents a set of specific subnetworks (also called metabolic modules) that reflect metabolic variability within a given transcriptional dataset.

Note, that it may take a long time to derive metabolic modules by `gamClustering()` function (tens of minutes).

There is a set of parameters which determine the size and number of your final modules. We recommend you to start with the default settings, however you can adjust them based on your own preferences:

1. If you consider final modules to bee too small or too big and it complicates interpretation for you, you can either increase or reduce by 10 units the `max.module.size` parameter. 

2. If among final modules you consider presence of any modules with too similar patterns, you can reduce by 0.1 units the `cor.threshold` parameter. 

3. If among final modules you consider presence of any uninformative modules, you can reduce by 10 times the `p.adj.val.threshold` parameter. 

```{r, eval = FALSE}
results <- gamClustering(E.prep = E.prep,
                         network.prep = network.prep,
                         cur.centers = cur.centers,
                         
                         start.base = 0.5,
                         base.dec = 0.05,
                         max.module.size = 50,

                         cor.threshold = 0.8,
                         p.adj.val.threshold = 0.00001,

                         batch.solver = seq_batch_solver(solver),
                         work.dir = work.dir,
                         
                         show.intermediate.clustering = TRUE,
                         verbose = TRUE,
                         collect.stats = TRUE)
```

### Visualizing and exploring the GAM-clustering results

Each metabolic module is a connected piece of metabolic network whose genes expression is correlated across all dataset.

The following functions will help you to visualize and explore the obtained results.

##### Get graphs of modules:

```{r, eval = FALSE}
getGraphs(modules = results$modules,
          network.annotation = network.annotation,
          metabolites.annotation = metabolites.annotation,
          seed.for.layout = 42,
          work.dir = work.dir)
```

##### Get gene tables:

The table contains gene list. Each gene has two descriptive values: i) gene's correlation value with the modules pattren and ii) gene's score.
High score means that this gene's expression is similar to the module's pattern and not similar to other modules' patterns.

```{r, eval = FALSE}
m.gene.list <- getGeneTables(modules = results$modules,
                             nets = results$nets,
                             patterns = results$patterns.pos,
                             gene.exprs = E.prep,
                             network.annotation = network.annotation,
                             work.dir = work.dir)
```

##### Get plots of patterns and individual genes expression:

For bulk data:

```{r, eval = FALSE}

# if use.PCA = TRUE:
# patterns <- data.frame(matrix(ncol=ncol(E), nrow = nrow(results$patterns.pos)))

# if use.PCA = FALSE:
patterns <- results$patterns.pos

for (i in seq_along(m.gene.list)) {
  
  # uncomment if use.PCA = TRUE:
  # patterns[i, ] <- getCenter(E, m.gene.list[[i]])
  
  heatmap <- E[m.gene.list[[i]], , drop=F]

  pheatmap::pheatmap(
    normalize.rows(heatmap),
    cluster_rows=F, cluster_cols=F,
    file=sprintf("%s/m.%s.genes.png", work.dir, i),
    width=10, height=5,
    show_rownames=T, show_colnames=T)
}

pheatmap::pheatmap(
  normalize.rows(patterns),
  cluster_rows=F, cluster_cols=F,
  file=file.path(work.dir, "m.patterns.pdf"),
  width=30, height=30,
  show_rownames=T, show_colnames=T)
```

For single-cell data:

```{r, eval=FALSE}
library(Seurat)
library(fgsea)

Seurat::DefaultAssay(seurat_object) <- "SCT"
      
for(i in seq_along(m.gene.list)){
  
  # print individuals:
  
  Seurat::FeaturePlot(seurat_object, 
                      slot = "data",
                      reduction = "umap",
                      features = m.gene.list[[i]],
                      ncol = 5,
                      combine = T)
  
  ggplot2::ggsave(file = sprintf("%s/m.%s.genes.png", work.dir, i), 
                  width = 15, 
                  height = round(length(m.gene.list[[i]]) / 5)*2 + 1)
  
  # print pattern:
  
  fgsea::plotCoregulationProfileReduction(m.gene.list[[i]], seurat_object, reduction = "umap")
  
  ggplot2::ggsave(file = sprintf("%s/m.%s.pattern.png", work.dir, i), 
                  width = 4.5, 
                  height = 4)

  } 
```

For spatial data:

```{r, eval=FALSE}
library(Seurat)
library(fgsea)

for(i in 1:length(m.gene.list)){
  
  # print individuals:
  
  Seurat::SpatialFeaturePlot(seurat_object, 
                             features = m.gene.list[[i]],
                             ncol = 8)
  
  ggplot2::ggsave(file = sprintf("%s/m.%s.genes.png", work.dir, i),
                  width = 18,
                  height = round(length(m.gene.list[[i]]) / 5)*2 + 1)
  
  # print pattern:

  fgsea::plotCoregulationProfileSpatial(m.gene.list[[i]], seurat_object)
  
  ggplot2::ggsave(file = sprintf("%s/m.%s.pattern.png", work.dir, i),
                  width = 4.5,
                  height = 4)
}
```

##### Get tables and plots with annotation of modules:

Functional annotation of obtained modules is done based on KEGG and Reactome canonical metabolic pathways.

```{r, eval = FALSE}
getAnnotationTables(network.annotation = network.annotation,
                    nets = results$nets,
                    work.dir = work.dir)

getAnnotationHeatmap(work.dir = work.dir, 
                     file_name = "Modules_heatmap.png")
```

##### Compare modules obtained in different runs:

You may also compare two results of running GAM-clustering on the same dataset (e.g. runs with different parameters) or compare two results of running GAM-clustering on different datasets (then set `same.data=FALSE`).

```{r, eval=FALSE, eval = FALSE}
modulesSimilarity(dir1 = work.dir,
                  dir2 = "/home/octopus/Documents/4projects/immGen/GAM-clustering/10_32_04_191021_Todorov_32/",
                  name1 = "new",
                  name2 = "old",
                  same.data = TRUE,
                  use.genes.with.pos.score = TRUE,
                  work.dir = work.dir,
                  file.name = "comparison.png")
```